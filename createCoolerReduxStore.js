/*
    This module creates a function that can be used as a replacement to Redux's createStore
    The only difference is that the reduced is not a single function, but an arbitrarily complex
    object which contains many "reducers" (functions that take the state and other infos and return 
    the next state) as properties first level or deep properties
    The store's dispatch function mirrors the reducers object:

    `dispatch()` calls `reducers()`
    `dispatch.setToken('azertyuiop')` call `reducers.setToken(state, 'azertyuiop')`
    `dispatch.todos.add('yo')` calls `reducers.todos.add(state, 'yo')`
    `dispatch.todos.clear()` calls `reducers.todos.clear(state)`
*/

import {createStore as reduxCreateStore, __DO_NOT_USE__ActionTypes } from 'https://unpkg.com/redux@4.0.1/es/redux.mjs'

const reduxInternalActionTypes = new Set([...Object.values(__DO_NOT_USE__ActionTypes)])

export function createStore(reducers, ...otherArgs){
    const noopReducer = state => state;

    const {getState, dispatch: reduxDispatch, subscribe, replaceReducer} = reduxCreateStore(noopReducer, ...otherArgs)

    function makeDispatchProxy(reducerObj, propSequence){
        return new Proxy(
            typeof reducerObj === 'function' ? noopReducer : {}, 
            {
                get(target, prop){
                    if(prop in reducerObj){
                        return makeDispatchProxy(reducerObj[prop], [...propSequence, prop])
                    }
                    else{
                        throw new TypeError(`No ${prop} property in \`reducers.${propSequence.join('.')}\``)
                    }
                },
                apply(target, thisArg, argList){
                    console.log('apply trap', propSequence, argList)
                    const reducer = reducerObj;

                    if(typeof reducer !== 'function'){
                        throw new TypeError(`\`reducers.${propSequence.join('.')}\` is not a function`)
                    }
                    else{
                        // call to replaceReducer pretty much makes the use of redux devtools in Firefox useless
                        replaceReducer((state, action) => {
                            // handle reduxInternalActionTypes.REPLACE action generated by call to replaceReducer
                            return reduxInternalActionTypes.has(action.type) ?
                                state : 
                                reducer(state, action);
                        })
                        
                        const reduxAction = argList[0];

                        if(!('type' in reduxAction))
                            reduxAction.type = propSequence.join('.')

                        return Reflect.apply(reduxDispatch, undefined, [reduxAction])
                    }
                }
            }
        ) 
    }

    return {
        getState, 
        subscribe,
        dispatch: makeDispatchProxy(reducers, [])
    }
}
